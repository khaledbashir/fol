# CORE RULE — ZERO BULLSHIT ENGINEERING

This system does not tolerate fake work, lazy shortcuts, or dishonest engineering.

## ABSOLUTE RULES (VIOLATION = REJECTION)

### 1. NO FAKE FUNCTIONALITY

**FORBIDDEN:**
- Simulated behavior
- Mocked responses in production
- "Thinking" animations that fake processing
- Pretending something works when it doesn't
- Demo data masquerading as real data

**REQUIRED:**
- Real functionality only
- Actual API calls
- Real state management
- True loading states
- Honest error handling

**ENFORCEMENT:**
```typescript
// ❌ FAKE - Simulated API response
const fetchUser = async () => {
  await new Promise(resolve => setTimeout(resolve, 1000));
  return { id: 1, name: "John Doe" }; // Fake data
};

// ✅ REAL - Actual API call
const fetchUser = async () => {
  const response = await fetch('/api/users/1');
  if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
  return response.json();
};
```

### 2. NO PLACEHOLDERS DISGUISED AS FEATURES

**FORBIDDEN:**
- Stub components shown to users
- TODO logic exposed as real features
- "Coming soon" features that partially run
- Empty states with fake interactions
- Disabled buttons that look clickable

**REQUIRED:**
- Unbuilt features are completely invisible
- Clear indication of what's not available
- Honest messaging about limitations
- Proper feature flags for incomplete functionality

**ENFORCEMENT:**
```typescript
// ❌ FAKE - Placeholder exposed as feature
const SearchBar = () => {
  return (
    <input 
      placeholder="Search (coming soon)" 
      disabled 
      className="cursor-not-allowed opacity-50"
    />
  );
};

// ✅ REAL - Either build it or hide it
const SearchBar = () => {
  const [isEnabled] = useState(false); // Feature flag
  
  if (!isEnabled) return null; // Hide if not built
  
  return <input placeholder="Search" />;
};
```

### 3. NO ERROR MASKING

**FORBIDDEN:**
- Hiding failures behind friendly messages
- Swallowing or softening errors
- Generic "Something went wrong" messages
- Silent failures
- Error boundaries that hide the real problem

**REQUIRED:**
- Show actual errors, even if ugly
- Preserve stack traces in development
- Log real errors for debugging
- Provide actionable error information
- Fail loudly and honestly

**ENFORCEMENT:**
```typescript
// ❌ FAKE - Error masking
try {
  await riskyOperation();
} catch (error) {
  console.log("Something went wrong"); // Lost the real error
  setError("Please try again later"); // Useless message
}

// ✅ REAL - Honest error handling
try {
  await riskyOperation();
} catch (error) {
  console.error("Operation failed:", error); // Real error
  setError(`Failed to ${operation}: ${error.message}`); // Actionable
  // Log to monitoring service with full context
}
```

### 4. NO LAZY HACKS

**FORBIDDEN:**
- Duct tape solutions
- "Temporary" fixes with no expiry
- Shortcuts to avoid proper architecture
- Copy-paste programming
- Hardcoded values that should be configurable

**REQUIRED:**
- Proper architecture from the start
- Clean, maintainable code
- Appropriate abstractions
- Configuration over hardcoding
- Technical debt tracking and repayment

**ENFORCEMENT:**
```typescript
// ❌ LAZY - Duct tape solution
const getUserRole = (userId: string) => {
  if (userId === "123") return "admin"; // Hardcoded hack
  if (userId === "456") return "moderator"; // More hacks
  return "user";
};

// ✅ REAL - Proper architecture
const getUserRole = async (userId: string) => {
  const user = await db.user.findUnique({ 
    where: { id: userId },
    select: { role: true }
  });
  return user?.role || 'user';
};
```

### 5. NO PROBLEM SWEEPING

**FORBIDDEN:**
- Patching symptoms instead of root causes
- Deferring structural flaws
- Silencing bugs instead of fixing them
- Working around known issues
- Ignoring performance bottlenecks

**REQUIRED:**
- Fix root causes or don't touch it
- Address structural issues head-on
- Eliminate bugs completely
- Refactor when needed
- Optimize performance properly

**ENFORCEMENT:**
```typescript
// ❌ SWEEPING - Patching symptoms
const SlowComponent = () => {
  const [data, setData] = useState([]);
  
  // Problem: Slow rendering
  useEffect(() => {
    const slowData = heavyComputation(data);
    setData(slowData);
  }, [data]);
  
  return <ExpensiveList data={data} />;
};

// ✅ REAL - Fix root cause
const SlowComponent = () => {
  const [data, setData] = useState([]);
  
  // Solution: Memoize and optimize
  const optimizedData = useMemo(() => heavyComputation(data), [data]);
  
  return (
    <VirtualizedList data={optimizedData} />
  );
};
```

### 6. REAL OR NOTHING

**FORBIDDEN:**
- Fake AI responses
- Mock data in production
- Simulated integrations
- Placeholder functionality
- Demo modes that look real

**REQUIRED:**
- Real AI responses
- Real data from actual sources
- Real integrations with external services
- Real behavior that matches production
- Honest limitations

**ENFORCEMENT:**
```typescript
// ❌ FAKE - Simulated AI response
const getAIResponse = async (prompt: string) => {
  await new Promise(resolve => setTimeout(resolve, 2000));
  return "This is a simulated AI response"; // Fake
};

// ✅ REAL - Actual AI integration
const getAIResponse = async (prompt: string) => {
  const response = await fetch('/api/ai/chat', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ prompt })
  });
  
  if (!response.ok) throw new Error('AI service unavailable');
  return response.json();
};
```

### 7. HACKS: RARE, DEFENSIBLE, AND IMPRESSIVE

Hacks are allowed ONLY if ALL of the following are true:

**THE CONSTRAINT IS REAL AND EXTERNAL:**
- API limitations you cannot change
- Browser bugs you cannot fix
- Performance constraints from hardware
- Third-party service restrictions

**THE HACK IS TECHNICALLY HONEST:**
- Clearly documents the limitation
- Doesn't pretend to be proper solution
- Exposes the trade-offs
- Makes the constraint visible

**THE HACK IS CLEVER, NOT EVASIVE:**
- Solves the problem elegantly
- Reduces complexity, doesn't hide it
- Makes the system better under constraints
- Would be respectable in a post-mortem

**YOU WOULD BE PROUD TO EXPLAIN IT:**
- You can justify it to a senior engineer
- It makes people go "that's actually smart"
- It's a smart constraint-aware design
- Not an apology for not doing the work

**ENFORCEMENT:**
```typescript
// ❌ BAD HACK - Lazy workaround
function fixIEBug() {
  // This is terrible, don't do this
  if (navigator.userAgent.indexOf('MSIE') !== -1) {
    // Some horrible hack
  }
}

// ✅ GOOD HACK - Clever constraint solution
/**
 * WORKAROUND: Safari doesn't support WebRTC getUserMedia on localhost
 * This uses a relay server for local development only
 * 
 * Trade-off: Adds latency in dev, enables real functionality
 * Remove when Safari fixes localhost WebRTC support
 */
const getSafariWorkaroundStream = async () => {
  if (isSafari() && isLocalhost()) {
    return await relayServer.getStream(); // Honest workaround
  }
  return await navigator.mediaDevices.getUserMedia(constraints);
};
```

## ENFORCEMENT PRINCIPLE

A hack should look like a smart constraint-aware design — not an apology for not doing the work.

**Build it right.**
**Or build it clever.**
**But never build it fake.**

### 8. SHIP OR IT DIDN'T HAPPEN

**FORBIDDEN:**
- Local-only changes that never reach production
- Features sitting in local branches for weeks
- Fixes that aren't deployed
- "I'll push it later" mentality
- Accumulating uncommitted work

**REQUIRED:**
- Every meaningful change must be pushed to GitHub
- Features must be deployed to be considered complete
- Fixes must reach production to be considered resolved
- Regular, frequent pushes (at least daily for active work)
- No "I'll clean it up later" - push it now

**ENFORCEMENT:**
```bash
# After every meaningful change:
git add .
git commit -m "feat: real feature that works"
git push origin main

# NO EXCUSES - PUSH IT NOW
```

**EXCEPTIONS:**
- Experimental/prototype code (clearly marked)
- Local debugging changes (committed and pushed with clear labels)
- Temporary workarounds (with expiry dates in commits)

---

## CODE REVIEW CHECKLIST

Before any code is merged:

- [ ] No fake functionality
- [ ] No placeholder features
- [ ] Real error handling
- [ ] No lazy hacks
- [ ] Root cause fixes
- [ ] Real integrations only
- [ ] Any hacks are documented and defensible
- [ ] Code is pushed to GitHub (SHIP IT)

**VIOLATION = IMMEDIATE REJECTION**